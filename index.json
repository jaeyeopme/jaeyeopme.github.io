[{"content":"1. 단위 테스트의 목표 단위 테스트에 시간을 투자할 때는 항상 노력은 가능한 줄이며 이득을 최대화해야 한다. 단위 테스트에 노력을 많이 들여도 많은 버그와 유지비로 진행은 느려진다. 균형을 달성한 프로젝트는 유지보수가 많이 필요하지 않으며, 변화하는 요구에 신속히 대응할 수 있다.\n1.1 단위 테스트 현황 단위 테스트를 적용해야 하는지는 더 이상 논쟁거리가 아니다. 기업용 애플리케이션은 거의 모두 자동화된 단위 테스트가 있고, 통합 테스트를 통해 좋은 커버리지를 달성하고 있다. 그러나 좋지 않은 테스트라면 새로운 기능 구현이 더 오래 걸리고, 새로운 버그가 나타나는 등 테스트가 오히려 상황을 더 나쁘게 할 수 있다. 논쟁은 \u0026lsquo;단위 테스트를 작성해야 하는가?\u0026rsquo; 에서 \u0026lsquo;좋은 단위 테스트를 작성하는 것은 어떤 의미인가?\u0026rsquo; 로 바뀌었다.\n1.2 단위 테스트의 목표 코드를 테스트하기 어렵다면 개선이 반드시 필요하다는 것을 의미한다. 보통 강결합에서 저품질이 나타난다. 하지만 테스트가 쉽다고 해도 반드시 코드 품질이 좋은 것은 아니다. 코드 설계는 단위 테스트의 주된 목표가 아닌, 좋은 부수 효과일 뿐이다.\n단위 테스트의 목표는 지속 가능한 성장을 가능하게 하는 것이다. 테스트가 없다면 시간이 지나면서 개발 속도는 현저히 느려지고, 코드베이스에서 코드를 변경할 때 지속적인 정리와 리팩터링 같은 관리를 하지 않는다면 회귀가 늘어나고, 더 이상 코드베이스를 신뢰할 수 없게 된다. 테스트는 안전망 역할을 하며, 대부분의 회귀에 대한 보험을 제공하기 때문에 코드베이스의 신뢰성을 높여준다.\n회귀란 특정 사건 후에 기능이 의도한대로 동작하지 않는 경우를 말한다.\n1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인 잘못 작성한 테스트는 프로젝트 성장에 큰 도움이 되지 않는다. 잘못 작성한 테스트와 전혀 없는 테스트는 거시적인 관점에서 큰 차이가 없다.\n모든 테스트를 작성할 필요는 없다. 단지 테스트를 더 많이 쏟아내도 일부 중요한 테스트를 제외한 나머지들은 프로젝트에 도움이 되는지를 파악하지 않고 테스트를 작성하는 데만 빠져들기 쉽다. 테스트의 가치와 유지 비용을 모두 고려해야 한다.\n비용 요소\n베이스코드를 리팩터링할 때 테스트도 같이 하라. 코드 변경 시 테스트를 실행하라. 테스트가 실패할 경우 처리하라. 베이스코드의 동작을 이해할 때 테스트를 읽는 데 시간을 투자하라. 지속 가능한 성장을 위해서는 고품질 테스트에만 집중해라. 코드는 자산이 아니라 책임이다. 코드가 많아질 수록 버그에 노출되는 면적은 넓어지고 유지비가 증가한다. 애플리케이션의 정확성 보장을 목표로하여 가능한 적은 코드로 문제를 해결하는 것이 좋다.\n1.3 테스트 스위트 품질 측정을 위한 커버리지 지표 가장 널리 사용되는 두 가지 커버리지 지표가 있다. 특정 커버리지 숫자를 목표로 하는 것은 해로우며, 테스트 스위트 품질을 결정할 때 커버리지 지표에 의존할 수 없다.\n커버리지 지표란 테스트 스위트가 소스 코드를 얼마나 실행하는지를 백분율로 나타낸다.\n일반적으로 커버리지 숫자가 높을수록 더 좋지만, 커버리지 지표는 중요한 피드백을 주더라도 품질을 측정하는 데 사용될 수 없다. 커버리지가 너무 적을 때는 테스트가 충분하지 않다는 것이지만, 반대의 경우는 반드시 양질의 테스트 스위트라고 보장되지 않는다.\n1.3.1 코드 커버리지 지표에 대한 이해 라인 수만 처리하기 때문에 개선이 아닌 코드를 바꾸기만해도 커버리지는 100% 로 증가할 수 있다.\n1.3.2 분기 커버리지 지표에 대한 이해 코드 라인 수를 사용하는 대신 if 문과 switch 문과 같은 제어 구조에 중점을 둔다. 코드 커버리지보다 더 정확한 결과를 제공하지만, 분기 개수만 다루기 때문에 분기를 구현하는 데 얼마나 코드가 필요한지 고려하지 않는다.\n1.3.3 커버리지 지표에 관한 문제점 가능한 모든 결과를 검증한다고 보장할 수 없다. 실행하는지가 아닌 시스템이 낸 결과가 정확히 예상하는 결과인지 확인하는 적절한 검증이 필요하다. 커버리지 지표는 실행만 한다면 상황 검증이 전혀 없는 테스트도 커버리지에 포함한다.\n외부 라이브러리의 코드 경로를 고려할 수 없다. 외부 라이브러리가 수행하는 코드 경로는 고려하지 않기 때문에 수많은 예외 상황에 빠질 수 있다. 이는 커버리지 지표가 고려해야한다는 것이 아니라(고려하면 안 된다.) 해당 지표로 코드의 품질을 확인할 수 없다는 것이다.\n1.3.4 특정 커버리지 숫자를 목표로 하기 특정 커버리지 숫자를 목표로 하는 것은 중요한 것을 테스트하는 데 집중하는 대신 인공적인 목표를 달성하기 위한 방법을 찾게 한다. 숫자를 강요하면 테스트 대상에 신경쓰지 못한다. 커버리지 숫자가 낮으면 문제 징후라 할 수 있지만 높은 숫자도 별 의미 없다.(핵심 부분은 요구 사항으로 삼는 것이 아니라면 높게 두는 것이 좋다.) 커버리지 측정은 성공적인 테스트 스위트를 위한 첫걸음이다.\n1.4 무엇이 성공적인 테스트 스위트를 만드는가? 테스트 스위트의 품질을 측정하는 방법은 각 테스트를 하나씩 따로 평가하는 것 뿐이다. 얼마나 좋은지 자동으로 확인할 수 없다.\n성공적인 테스트 스위트의 특성\n개발 주기에 통합돼 있다. 코드베이스에서 가장 중요한 부분만을 대상으로 한다. 최소한의 유지비로 최대의 가치를 끌어낸다. 1.4.1 개발 주기에 통합돼 있음 자동화된 테스트는 끊임없이 하는것 뿐이며, 이상적으로는 코드가 변경될 때마다 작은 것이라도 실행해야 한다.\n1.4.2 코드베이스에서 가장 중요한 부분만을 대상으로 함 가장 중요한 부분에 노력을 기울이고, _다른 부분_은 간략하게 또는 간접적으로 검증하는 것이 좋다. 비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다.\n다른 부분\n인프라 코드 데이터베이스나 서드파티와 같은 외부 서비스 및 종속성 퍼사드 코드 다른 부분에 복잡하고 중요한 알고리즘을 철저하게 테스트 해야할 수 있지만, 일반적으로 도메인 모델에 관심을 더 많이 갖는 것이 좋다. 통합 테스트와 같이 전체적인 작동을 테스트 하는 것도 괜찮다. 하지만 초점은 도메인 모델에 머물러야 하며, 이를 따르려면 도메인 모델을 다른 애플리케이션 문제와 분리해야 집중할 수 있다.\n1.4.3 최소 유지비로 최대 가치를 끌어냄 가장 어려운 특성이며, 테스트를 빌드 시스템에 통합하는 것만으로 충분하지 않고, 도메인 모델에 높은 커버리지를 유지하는 것도 충분하지 않다. 가치가 유지비를 상회하는 테스트만 스위트에 유지하는 것이 중요하다. 이를 달성하기 위해 가치 있는 테스트를 식별하는 것은 중요하다.\n단위 테스트와 코드베이스는 서로 얽혀 있으므로 코드베이스의 설계에 노력을 많이 기울이지 않으면 가치 있는 테스트를 만들 수 없다.\n","permalink":"https://jaeyeopme.github.io/posts/%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-1%EC%9E%A5/","summary":"1. 단위 테스트의 목표 단위 테스트에 시간을 투자할 때는 항상 노력은 가능한 줄이며 이득을 최대화해야 한다. 단위 테스트에 노력을 많이 들여도 많은 버그와 유지비로 진행은 느려진다. 균형을 달성한 프로젝트는 유지보수가 많이 필요하지 않으며, 변화하는 요구에 신속히 대응할 수 있다.\n1.1 단위 테스트 현황 단위 테스트를 적용해야 하는지는 더 이상 논쟁거리가 아니다. 기업용 애플리케이션은 거의 모두 자동화된 단위 테스트가 있고, 통합 테스트를 통해 좋은 커버리지를 달성하고 있다. 그러나 좋지 않은 테스트라면 새로운 기능 구현이 더 오래 걸리고, 새로운 버그가 나타나는 등 테스트가 오히려 상황을 더 나쁘게 할 수 있다.","title":"단위 테스트 1장"},{"content":"HTTP 0.9 GET 메서드 지원 텍스트 정보 전송 지원 1.0 페이로드와 헤더 지원 다양한 헤더 지원 Content-Type 이미지나 동영상 등 다양한 정보 전송 지원 Content-Encoding (최적화 기법) 압축 정보를 공유하여 압축 전송 지원 POST 메서드 지원 1.1 다양한 HTTP 메서드 지원 PUT, DELETE 등 지속적 연결 지원 TCP 연결을 재사용하여 파이프라이닝 먼저 보낸 요청의 응답을 완전하게 받지 않아도 다음 요청을 병렬적으로 처리하여 전체 전달시간을 줄이는 방식 요청만 병렬적으로 수행하기 때문에 응답은 여전히 FIFO 방식 HOL(Head Of-Line blocking) 문제 서버가 하나의 요청에 응답을 지연하면 나머지 모든 응답 역시 지연 2.0 프로토콜 경량화 텍스트 방식을 버리고 바이너리를 사용하여 프로토콜 경량화 헤더와 페이로드가 이진형태의 프레임으로 추상화 이진 프레임 프레임: 제일 작은 정보 단위이며 헤더나 데이터 중 하나 메시지: HTTP/1.1 마찬가지로 요청 혹은 응답 단위이며 다수의 프레임으로 이루어짐 스트림: 클라이언트와 서버 사이 맺어진 연결을 통해 양방향으로 주고받는 하나 혹은 복수의 메시지 스트림 식별자 스트림에는 식별자가 있는데 요청과 응답은 같은 식별자를 가짐 프레임 헤더에 있는 식별자를 통해 프레임을 재조립하기 때문에 서버 측에서 요청 순서에 상관 없이 식별하여 응답 가능 멀티플렉싱 스트림 식별자를 통해 요청 순서가 보장되기 때문에 응답 프레임들은 요청 순서에 상관 없이 만들어진 순서대로 전달 요청과 응답 모두 병렬적으로 수행 HOL 문제 해결 헤더 압축 기존에는 Content-Encoding 헤더를 통해 페이로드만 압축 가능 가상 테이블 클라이언트와 서버 사이에 중복된 헤더 값들을 테이블에 저장하고 참고하는 방식으로 중복 전달 제거 각 테이블에는 인덱스 번호가 있기 때문에 동일한 값을 전송할 때는 중복 값을 보내는 대신 인덱스 번호로 대체하여 전송 정적 테이블과 동적 테이블로 나눠짐 정적 테이블 미리 정의된 자주 사용되는 헤더 필드 저장 동적 테이블 통신하며 주고받는 값들을 업데이트 HPACK 압축 알고리즘을 사용하여 허프만 알고리즘 방식으로 헤더를 압축 허프만 알고리즘 자주 등장하는 값과 그렇지 않은 값 마다 코드 값을 다르게 부여하는 알고리즘 스트림 우선 순위 설정 서버 푸시 클라이언트가 요청하지 않아도 미리 전송하여 RTT 최소화 가능 예를 들어 HTML을 호출한 후 후속으로 해당 페이지가 호출하는 CSS 파일이나 자바스크립트, 이미지 등 대상이 고정되어 있다면 서버 푸시 대상으로 미리 설정 가능 최근 APM 솔루션들은 서버 푸시 대상을 자동으로 설정해주는 기능을 포함 후속 파일 대상이 변경되어도 이를 자동으로 탐지하고 적용하는 기능이 포함 3.0 QUIC (Quick UDP Internet Connections) UDP 를 채택해 TCP 성능을 개선하려는 기술 속도 향상과 연결 수를 최소화하고 대역폭을 예상해 패킷 혼잡을 피하는것이 주요 목적 Zero RTT 이전에 한번이라도 접속했던 서버라면, 별도의 정보교환 없이 바로 데이터를 보냄 3 hand-shaking 캐시 HQ (HTTP over QUIC) TCP/IP 기반 애플리케이션 레이어 프로토콜인 HTTP 를 QUIC 위로 위치 시킴 HTTP 3을 도입했을 때 나오는 변화들은 HTTP 3 때문이 아니라 QUIC 때문임 HTTP 3는 통신을 하려는 장치일 뿐 TLS 1.3 QUIC 은 프로토콜 단에서 암호화된 통신을 강제함 TLS 핸드 셰이크와 QUIC 핸드 셰이크가 동시에 발생하기 때문에 라운드 트립을 한번 절약하는 효과 암호화 영역 확장 헤더 필드 영역까지 암호화되기 때문에 헤더의 정보를 사용하는 ISP 나 네트워크 중계회사들은 도입 시 주의해야함 보안성은 강화했지만 패킷별로 암호화하기 때문에 TSL-TCP 에서 패킷을 묶어서 암호화하는것 보다 더 큰 리소스 소모가 생김 여러 파일 동시 통신 TCP 는 하나의 커넥션을 하나의 파일로 취급하기 때문에 로스가 발생하면, 해당 파일 뿐만 아니라 TCP 커넥션을 공유하는 다른 파일들의 패킷도 중단되는 문제가 발생할 수 있음 QUIC 는 개별 파일을 구분하기 때문에 패킷 로스가 발생해도 해당 파일의 스트림만 정지되도록 가능 커넥션 유지 커넥션을 구분하기 위해서는 클라이언트와 서버 각각의 아이피와 포트 이렇게 네가지가 필요 모바일 환경에서 와이파이존에서 데이터를 사용할 경우 일시적 지연이 일어나는 이유는 클라이언트 아이피가 바뀌기 때문 TCP 통신에서는 핸드 셰이크부터 다시 해야함 서버와 클라이언트는 커넥션 ID 를 기억하여 핸드셰이크를 진행하지 않아도 됌 ","permalink":"https://jaeyeopme.github.io/posts/http-%EC%9A%94%EC%95%BD/","summary":"HTTP 0.9 GET 메서드 지원 텍스트 정보 전송 지원 1.0 페이로드와 헤더 지원 다양한 헤더 지원 Content-Type 이미지나 동영상 등 다양한 정보 전송 지원 Content-Encoding (최적화 기법) 압축 정보를 공유하여 압축 전송 지원 POST 메서드 지원 1.1 다양한 HTTP 메서드 지원 PUT, DELETE 등 지속적 연결 지원 TCP 연결을 재사용하여 파이프라이닝 먼저 보낸 요청의 응답을 완전하게 받지 않아도 다음 요청을 병렬적으로 처리하여 전체 전달시간을 줄이는 방식 요청만 병렬적으로 수행하기 때문에 응답은 여전히 FIFO 방식 HOL(Head Of-Line blocking) 문제 서버가 하나의 요청에 응답을 지연하면 나머지 모든 응답 역시 지연 2.","title":"HTTP 요약"},{"content":"SRP: 단일 책임 원칙 (Single responsibility principal) SRP는 단일 책임 원칙을 의미한다. SRP는 \u0026lsquo;하나의 객체가 하나의 책임만 져야 한다\u0026rsquo;는 의미이다. SRP는 클래스를 단 한 가지 목표만 가지고 작성해야 한다는 것을 의미한다. SRP는 애플리케이션 모듈 전반에서 높은 유지보수성과 가시성 제어 기능을 유지하는 원칙이다. 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야한다.\n클린 아키텍처 66p\n예제 SRP를 따르지 않는 경우 일반적으로 클래스가 수행하는 일을 표현하기 위해 \u0026lsquo;또한\u0026rsquo; 이라는 단어를 사용해야 한다면 SRP 원칙이 깨진 것이라고 할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class RectangleAreaCalculator { private static final double INCH_TERM = 0.0254d; private final int width; private final int height; public RectangleAreaCalculator(int width, int height) { this.width = width; this.height = height; } public int area() { return width * height; } // SRP 위배 public double metersToInches(int area) { return area / INCH_TERM; } } SRP를 따르는 경우 metersToInches 메서드를 제거하면 SRP를 준수할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class RectangleAreaCalculator { private final int width; private final int height; public RectangleAreaCalculator(int width, int height) { this.width = width; this.height = height; } public int area() { return width * height; } } // 변환에 대한 책임을 별도의 객체로 분리 public class AreaConverter { private static final double INCH_TERM = 0.0254d; private static final double FEET_TERM = 0.3048d; public double metersToInches(int area) { return area / INCH_TERM; } // 변환 메서드 추가 가능 public double metersToFeet(int area) { return area / FEET_TERM; } } OCP: 개방-폐쇄 원칙 (Open-closed Principal) OCP는 개방-폐쇄 원칙을 의미한다. OCP는 \u0026lsquo;소프트웨어 컴포넌트는 확장에 관해 열려 있어야 하고 변경에 관해서는 닫혀야 한다\u0026rsquo;는 의미이다. OCP는 다른 개발자가 작업을 수행하기 위해 반드시 변경해야 하는 제약 사항을 클래스에 포함해서는 안 된다는 사실을 의미한다. 다른 개발자가 클래스를 확장하기만 하면 원하는 작업을 할 수 있도록 해야한다. OCP는 다양하고 직관적이며 유해하지 않은 방식으로 소프트웨어 확장성을 유지하는 원칙이다. 예제 OCP를 따르지 않는 경우 각 도형은 면적을 구하기 위한 고유의 공식이 있으므로, 유형을 구분하는 로직이 필요하다. 또한 삼각형 같은 새로운 도형을 추가하고 싶으면 AreaCalculator 클래스를 수정해야한다. (반드시 변경해야 하는 제약 사항이 포함)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public interface Shape { } public class Rectangle implements Shape { private final int width; private final int height; // 생성자 및 getter 생략 } public class Circle implements Shape { private final int radius; // 생성자 및 getter 생략 } public class AreaCalculator { private final List\u0026lt;Shape\u0026gt; shapes; // 생성자 생략 // 도형을 추가하려면 로직를 변경해야함 (if-else or switch) // OCP 위배 public double sum() { double sum; for (Shape shape : shapes) { if (shape.getClass().equals(Circle.class)) { sum += Math.PI * Math.pow(((Circle) shape).getRadius(), 2); } else if (shape.getClass().equals(Rectangle.class)) { sum += ((Rectangle) shape).getHeight() * ((Rectangle) shape).getWidth(); } } return sum; } } OCP를 따르는 경우 OCP를 따르지 않는 코드를 리펙토링하는건 간단한 예제에서조차 까다롭다. AreaCalculator에서 도형의 면적 계산 메서드를 추상화하여 각 도형에 해당하는 클래스가 구현하도록 한다. 메서드를 변경하지 않고 Shape 인터페이스만 구현한다면 새로운 도형을 추가할 수 있으므로 변경에 관해 닫혀 있으면서 확장에 관해 열려있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public interface Shape { double getArea(); } public class Rectangle implements Shape { private final int width; private final int height; // 생성자 및 getter 생략 @Override public double getArea() { return width * height; } } public class Circle implements Shape { private final int radius; // 생성자 및 getter 생략 @Override public double getArea() { return Math.PI * Math.pow(radius, 2); } } public class AreaCalculator { private final List\u0026lt;Shape\u0026gt; shapes; // 생성자 생략 public double sum() { return shapes.stream().mapToDouble(Shape::getArea).sum(); } } LSP: 리스코프 치환 원칙 (Liskov substitution principle) LSP 는 리스코프 치환 원칙을 의미한다. LSP 는 \u0026lsquo;하위 타입은 반드시 상위 타입을 완벽하게 대체할 수 있어야 한다\u0026rsquo;는 의미이다. LSP 는 \u0026lsquo;하위 클래스의 객체는 상위 클래스의 객체와 반드시 같은 방식으로 동작해야한다\u0026rsquo;는 사실을 의미한다. LSP 는 타입 변환 후에 뒤따라오는 런타임 타입 식별에 유용한 원칙이다. 1998년 바바라 리스코프는 하위 타입을 아래와 같이 정의 했다.\nS타입의 객체 o1 각각에 대응하는 T타입 객체 o2가 있고, T타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.\n클린 아키텍처 82p\n예제 LSP를 따르지 않는 경우 FreeMember는 토너먼트에 참가할 수 있지만 주최할 수 없기 때문에 상위 클래스와 같은 방식으로 동작할 수 없다. 예외를 발생시키거나 문구를 표시한다고해서 원칙을 지키는것이 아니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 public abstract class Member { private final String name; public Member(String name) { this.name = name; } public abstract void joinTournament(); public abstract void organizeTournament(); } public class PremiumMember extends Member { public PremiumMember(String name) { super(name); } @Override public void joinTournament() { System.out.println(\u0026#34;Premium member joins tournament ...\u0026#34;); } @Override public void organizeTournament() { System.out.println(\u0026#34;Premium member organize tournament ...\u0026#34;); } } public class VipMember extends Member { // PremiumMember와 거의 동일 } public class FreeMember extends Member { public FreeMember(String name) { super(name); } @Override public void joinTournament() { System.out.println(\u0026#34;Classic member joins tournament ...\u0026#34;); } // LSP 위배 @Override public void joinTournament() { System.out.println(\u0026#34;A free member cannot organize tournaments\u0026#34;); } } public class Main { public static void main(String[] args) { // FreeMember 클래스는 체스 토너먼트를 주최할 수 없기 때문에 필요한 작업을 할 수 없다. List.of( new PremiumMember(\u0026#34;Premium member\u0026#34;), new VipMember(\u0026#34;Vip member\u0026#34;), new FreeMember(\u0026#34;Free member\u0026#34;) ) .stream() .forEach(Member::organizeTournament); } } LSP를 따르는 경우 Member 인터페이스의 책임을 분리한다. TournamentJoiner, TournamentOrganizer\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 public interface TournamentJoiner { void joinTournament(); } public interface TournamentOrganizer { void organizeTournament(); } public abstract class Member implements TournamentJoiner, TournamentOrganizer { private final String name; public Member(String name) { this.name = name; } } public class PremiumMember extends Member { // 생략 } public class VipMember extends Member { // 생략 } public class FreeMember implements TournamentJoiner { // 중복 코드 private final String name; // 생성자 생략 @Override public void joinTournament() { System.out.println(\u0026#34;Classic member joins tournament ...\u0026#34;); } } public class Main { public static void main(String[] args) { List.of( new PremiumMember(\u0026#34;Premium member\u0026#34;), new FreeMember(\u0026#34;Free member\u0026#34;), new VipMember(\u0026#34;Vip member\u0026#34;) ) .stream() .forEach(TournamentJoiner::joinTournament); List.of( new PremiumMember(\u0026#34;Premium member\u0026#34;), new VipMember(\u0026#34;Vip member\u0026#34;) ) .stream() .forEach(TournamentOrganizer::organizeTournament); } } ISP: 인터페이스 분리 원칙 (Interface segregation principle) ISP는 인터페이스 분리 원칙을 의미한다. ISP는 \u0026lsquo;클라이언트가 사용하지 않을 불필요한 메서드를 강제로 구현해서는 안된다\u0026rsquo;는 의미이다. ISP는 클라이언트가 사용하지 않을 메서드를 강제로 구현하는 일이 없을 때까지 하나의 인터페이스를 2개 이상으로 분할하는 원칙이다. 예제 ISP를 따르지 않는 경우 WwwPingConnection 클래스는 socket 메서드는 필요하지 않다. 하지만 Connection 인터페이스를 구현하므로 socket 메서드도 강제로 구현해야한다. connect 메서드에 의해 발생하는 예외 또는 \u0026lsquo;소켓을 지원하지 않습니다\u0026rsquo;와 같은 예외를 발생시킬 수도 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public interface Connection { void socket(); void http(); void connect(); } public class WwwPingConnection implements Connection { private final String www; // 생성자 생략 @Override public void http() { System.out.println(\u0026#34;Setup an HTTP connection to \u0026#34; + www); } @Override public void connect() { System.out.println(\u0026#34;Connect to \u0026#34; + www); } // ISP 원칙 위배 @Override public void socket() { } } public class Main { public static void main(String[] args) { WwwPingConnection www = new WwwPingConnection(\u0026#34;www.google.com\u0026#34;); // 이 메서드는 아무것도 하지 않지만, 클라이언트는 그것을 알지 못한다. www.socket(); www.connect(); } } ISP를 따르는 경우 Connection 인터페이스를 하위 인터페이스로 책임을 분리 시킨다. HttpConnection, SocketConnection connect 메서드는 모든 클라이언트에서 필요하므로 공통된 상위 인터페이스에 선언한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public interface Connection { void connect(); } public interface HttpConnection extends Connection { void http(); } public interface SocketConnection extends Connection { void socket(); } public class WwwPingConnection implements HttpConnection { private final String www; // 생성자 생략 @Override public void http() { System.out.println(\u0026#34;Setup an HTTP connection to \u0026#34; + www); } @Override public void connect() { System.out.println(\u0026#34;Connect to \u0026#34; + www); } } DIP: Dependency inversion principle DIP는 의존관계 역전 원칙을 의미한다. DIP는 \u0026lsquo;구체화가 아닌 추상화에 의존해야한다\u0026rsquo;는 의미이다. DIP는 다른 구체에 의존하는 구체 대신, 구체를 결합하기 위한 추상 계층을 사용한다는 의미이다. DIP는 구 체를 분리합니다. 이 아이디어를 규칙으로 보기는 확실히 비현실적이다. 소프트웨어 시스템이라면 구체적인 많은 장치에 반드시 의존하기 때문이다. DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다. 우리는 이들 환경에 대한 의존성은 용납하는데, 변경되지 않는다면 의존할 수 있다는 사실을 이미 알고 있기 때문이다. 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소다.\n변동성이 큰 구체 클래스를 참조하지 말라. 변동성이 큰 구체 클래스로부터 파생하지 말라. 구체 함수를 오버라이드 하지 말라. 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라. 클린 아키텍처 92 ~ 94p\n예제 DIP를 따르지 않는 경우 MySQLJdbcUrl과 같은 다른 JDBC URL 타입을 사용하는 경우라면 connect(PostSQLJdbcUrl postgresql) 메서드를 사용할 수 없다. 따라서 구체화에 대한 의존 관계를 버리고 추상화에 대한 의존관계를 만들어야 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class PostgreSQLJdbcUrl { private final String dbName; // 생성자 생략 public String get() { return \u0026#34;jdbc:postgresql:// ... \u0026#34; + this.dbName; } } public class ConnectToDatabase { public void connect(PostgreSQLJdbcUrl postgresql) { System.out.println(\u0026#34;Connecting to \u0026#34; + postgresql.get()); } } DIP를 따르는 경우 ConnectToDatabase 클래스의 connect 메서드는 JdbcUrl 인터페이스에 의존하기 때문에 추상화를 구현하는 모든 JDBC URL에 연결할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public interface JdbcUrl { String get(); } public class PostgreSQLJdbcUrl implements JdbcUrl { private final String dbName; // 생성자 생략 @Override public String get() { return \u0026#34;jdbc:postgresql:// ... \u0026#34; + this.dbName; } } public class MySQLJdbcUrl implements JdbcUrl { private final String dbName; // 생성자 생략 @Override public String get() { return \u0026#34;jdbc:mysql:// ... \u0026#34; + this.dbName; } } public class ConnectToDatabase { public void connect(JdbcUrl jdbcUrl) { System.out.println(\u0026#34;Connecting to \u0026#34; + jdbcUrl.get()); } } 정리 SRP: 단일 책임 원칙 콘웨이 법칙에 따른 따름정리: 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 따라서 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.\nOCP: 개방-폐쇄 원칙 1980년대에 버트란트 마이어에 의해 유명해진 원칙이다. 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다는 것이 이 원칙의 요지다.\nLSP: 리스코프 치환 원칙 1988년 바바라 리스코프가 정의한, 하위 타입에 관한 유명한 원칙이다. 요약하면, 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성 요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.\nISP: 인터페이스 분리 원칙 이 원칙에 따르면 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.\nDIP: 의존성 역전 원칙 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.\n클린 코드 63 ~ 64p\n","permalink":"https://jaeyeopme.github.io/posts/solid/","summary":"SRP: 단일 책임 원칙 (Single responsibility principal) SRP는 단일 책임 원칙을 의미한다. SRP는 \u0026lsquo;하나의 객체가 하나의 책임만 져야 한다\u0026rsquo;는 의미이다. SRP는 클래스를 단 한 가지 목표만 가지고 작성해야 한다는 것을 의미한다. SRP는 애플리케이션 모듈 전반에서 높은 유지보수성과 가시성 제어 기능을 유지하는 원칙이다. 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야한다.\n클린 아키텍처 66p\n예제 SRP를 따르지 않는 경우 일반적으로 클래스가 수행하는 일을 표현하기 위해 \u0026lsquo;또한\u0026rsquo; 이라는 단어를 사용해야 한다면 SRP 원칙이 깨진 것이라고 할 수 있다.","title":"SOLID"},{"content":"대규모 서비스를 운영할 때 대용량 트래픽을 부하 분산하기 위해 사용하는 시스템의 확장 방식인 스케일 업과 스케일 아웃에 대해 알아본다.\n스케일 업 (Scale Up) 스케일 업이란 기존 서버를 보다 높은 사양으로 CPU 나 RAM 등과 같이 하드웨어를 업그레이드하여 한대의 단일 서버가 부하를 처리할 수 있게하는 확장 방식이다. 한대의 단일 서버의 성능을 증강하기 때문에 스케일 업을 (수직 스케일 - Vertical Scaling) 이라고 부르기도 한다.\n장점 단일 서버이기 때문에 소프트웨어 라이선스 비용이나 운영 비용이 적다. 데이터 정합성 이슈에서 자유롭다. 하드웨어적인 부분만 업그레이드하면되기 때문에 확장이 쉽다. 단점 성능 증가에 따른 비용 증가폭이 크다. 하드웨어를 업그레이드하는 방식이기 때문에 확장에 한계가 있다. 장애 발생 시 서버가 다운되었을 경우 복구되기 전까지 서비스를 중단해야하는 상황이 발생할 수 있다. 스케일 아웃 (Scale Out) 스케일 아웃이란 기존 서버와 같거나 비슷한 사양의 서버를 여러대 추가하여 로드 밸런서를 이용하여 여러 대의 서버가 부하를 처리할 수 있게하는 확장 방식이다. 여러대의 서버를 사용하기 때문에 스케일 아웃을 (수평 스케일 - Horizontal Scaling) 이라고 부르기도 한다.\n장점 일반적으로 저렴한 서버를 사용하므로 성능 증가에 따른 비용 부담이 적다. 여러대의 서버이기 때문에 장애가 발생하더라도 다른 노드에서 처리하는 방식으로 가용성을 높일 수 있다. 분산 처리 환경이기 때문에 장애 시 전면 장애의 가능성이 적다. 단점 여러대의 서버이기 때문에 소프트웨어 라이센스 비용이나 운영 비용이 크다. 데이터 정합성 이슈가 있기 때문에 글로벌 스토리지가 추가적으로 필요하다. 분산 처리 환경이기 때문에 로드 밸런싱이 필요하다. 비교 스케일 업은 한대의 서버에 모든 데이터를 처리하기 때문에 데이터 갱신이 빈번하게 일어나는 데이터베이스 서버에 적합한 방식이다. 스케일 아웃은 여러대의 서버가 동일란 데이터를 가지고 있기 때문에 데이터 변화가 적고 대용량 트래픽을 병렬 처리 할 수 있는 웹 서버에 적합한 방식이다. Reference https://medium.com/faun/scaling-applications-in-the-cloud-52bb6dfbac4e https://tech.gluesys.com/blog/2020/02/17/storage_3_intro.html ","permalink":"https://jaeyeopme.github.io/posts/%EC%84%9C%EB%B2%84-scaling-%EC%9D%B4%EB%9E%80/","summary":"대규모 서비스를 운영할 때 대용량 트래픽을 부하 분산하기 위해 사용하는 시스템의 확장 방식인 스케일 업과 스케일 아웃에 대해 알아본다.\n스케일 업 (Scale Up) 스케일 업이란 기존 서버를 보다 높은 사양으로 CPU 나 RAM 등과 같이 하드웨어를 업그레이드하여 한대의 단일 서버가 부하를 처리할 수 있게하는 확장 방식이다. 한대의 단일 서버의 성능을 증강하기 때문에 스케일 업을 (수직 스케일 - Vertical Scaling) 이라고 부르기도 한다.\n장점 단일 서버이기 때문에 소프트웨어 라이선스 비용이나 운영 비용이 적다.","title":"서버 Scaling"},{"content":"문제 @Embeddable 객체 내부에 @ManyToMany 로 연관관계 매핑 중 mappedBy 설정에서 연관관계 주인 필드를 인식하지 못한다.\nIntelliJ (2022.1.1 버전 기준) 에서도 인식을 못한다. 해결책 mappedBy 속성을 embedded.embeddable 형식으로 지정하면 IDE 에서는 인식하지 못하지만 JPA EntityManagerFactory 에서는 정상적으로 매핑된다. 하지만 IntelliJ 에서는 여전히 인식하지 못한다.\n여전히 인식하지 못한다. ","permalink":"https://jaeyeopme.github.io/posts/jpa-embeded-%ED%8A%B8%EB%9E%98%ED%82%B9-%EC%8B%A4%ED%8C%A8-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0/","summary":"문제 @Embeddable 객체 내부에 @ManyToMany 로 연관관계 매핑 중 mappedBy 설정에서 연관관계 주인 필드를 인식하지 못한다.\nIntelliJ (2022.1.1 버전 기준) 에서도 인식을 못한다. 해결책 mappedBy 속성을 embedded.embeddable 형식으로 지정하면 IDE 에서는 인식하지 못하지만 JPA EntityManagerFactory 에서는 정상적으로 매핑된다. 하지만 IntelliJ 에서는 여전히 인식하지 못한다.\n여전히 인식하지 못한다. ","title":"JPA Embeded IntelliJ 인식 실패"},{"content":" my.cnf 수정 1 2 3 4 5 6 7 8 9 10 11 12 $ vi /etc/mysql/my.cnf [client] default-character-set=utf8mb4 [mysql] default-character-set=utf8mb4 [mysqld] collation-server = utf8mb4_unicode_ci init-connect=\u0026#39;SET NAMES utf8mb4\u0026#39; character-set-server = utf8mb4 인코딩 설정 전 인코딩 설정 후 Reference https://mariadb.com/kb/en/setting-character-sets-and-collations/ https://medium.com/oldbeedev/mysql-utf8mb4-character-set-설정하기-da7624958624/ ","permalink":"https://jaeyeopme.github.io/posts/mariadb-%EC%9D%B8%EC%BD%94%EB%94%A9-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/","summary":" my.cnf 수정 1 2 3 4 5 6 7 8 9 10 11 12 $ vi /etc/mysql/my.cnf [client] default-character-set=utf8mb4 [mysql] default-character-set=utf8mb4 [mysqld] collation-server = utf8mb4_unicode_ci init-connect=\u0026#39;SET NAMES utf8mb4\u0026#39; character-set-server = utf8mb4 인코딩 설정 전 인코딩 설정 후 Reference https://mariadb.com/kb/en/setting-character-sets-and-collations/ https://medium.com/oldbeedev/mysql-utf8mb4-character-set-설정하기-da7624958624/ ","title":"MariaDB 인코딩 설정"},{"content":"이미지 다운로드 버전을 명시하지 않으면 latest 버전이 설치된다.\n1 $ docker pull mariadb:${VERSION} 컨테이너 생성 컨테이너 내부에 저장된 데이터들은 컨테이너가 삭제된다면 같이 삭제된다. 즉 stateful 하기 때문에 데이터의 영속성을 보장하는 stateless 한 설계를 위해 Docker 는 volumes 과 bind mounts 라는 두가지 옵션을 제공한다.\nvolumes 와 bind mounts 의 차이\n1. Use volumes 존재하지 않는 볼륨명 입력 시 입력된 볼륨명으로 볼륨이 생성되고, 생략 시 해시 값으로 볼륨이 생성된다.\nMYSQL_ROOT_PASSWORD 는 필수 환경 변수 이며, 컨테이너 실행 실패 시 docker logs ${CONTAINER_NAME} 명령어로 내부 로그를 확인할 수 있다.\n1 2 $ docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} -v ${VOLUME_NAME}:/var/lib/mysql --name ${CONTAINER_NAME} mariadb 2. Use bind mounts 1 2 $ docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD} \\ -v ${HOST}:/var/lib/mysql --name ${CONTAINER_NAME} mariadb 컨테이너 접속 1 $ docker exec -it ${CONTAINER_NAME} bash Reference https://mariadb.com/kb/en/installing-and-using-mariadb-via-docker/ https://docs.docker.com/storage/bind-mounts/ https://docs.docker.com/storage/volumes/ ","permalink":"https://jaeyeopme.github.io/posts/%EB%8F%84%EC%BB%A4%EB%A1%9C-mariadb-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0/","summary":"이미지 다운로드 버전을 명시하지 않으면 latest 버전이 설치된다.\n1 $ docker pull mariadb:${VERSION} 컨테이너 생성 컨테이너 내부에 저장된 데이터들은 컨테이너가 삭제된다면 같이 삭제된다. 즉 stateful 하기 때문에 데이터의 영속성을 보장하는 stateless 한 설계를 위해 Docker 는 volumes 과 bind mounts 라는 두가지 옵션을 제공한다.\nvolumes 와 bind mounts 의 차이\n1. Use volumes 존재하지 않는 볼륨명 입력 시 입력된 볼륨명으로 볼륨이 생성되고, 생략 시 해시 값으로 볼륨이 생성된다.\nMYSQL_ROOT_PASSWORD 는 필수 환경 변수 이며, 컨테이너 실행 실패 시 docker logs ${CONTAINER_NAME} 명령어로 내부 로그를 확인할 수 있다.","title":"MariaDB 컨테이너 환경 구성"},{"content":"\nHeading 1 2 3 4 5 6 7 8 9 10 11 # H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 H1 H2 H3 H4 H5 H6 Bold 1 **bold text** bold text\nItalic 1 _italicized text_ italicized text\nStrikethrough 1 ~~The world is flat.~~ The world is flat.\nEmoji 1 2 3 :kissing_closed_eyes: :satisfied: :stuck_out_tongue_winking_eye: :kissing_closed_eyes: :satisfied: :stuck_out_tongue_winking_eye:\nBlockquote 1 2 3 4 5 \u0026gt; blockquote1 \u0026gt; \u0026gt; \u0026gt; blockquote2 \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; blockquote3 blockquote1\nBlockquote2\nblockquote3\nOrdered List 1 2 3 1. First item 2. Second item 3. Third item First item Second item Third item Unordered List 1 2 3 - First item - Second item - Third item First item Second item Third item Code 1 `code` code\nLink 1 [title](https://www.example.com) title\nImage 1 ![alt text](image.png){: width=\u0026#34;50%\u0026#34; height=\u0026#34;50\u0026#34;} Table 1 2 3 | Default | Left | Center | Right | | ------- | :--- | :----: | ----: | | Text | Text | Text | Text | Default Left Center Right Text Text Text Text Fenced Code Block 1 2 3 4 5 6 7 ```json { \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Smith\u0026#34;, \u0026#34;age\u0026#34;: 25 } ``` 1 2 3 4 5 { \u0026#34;firstName\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;Smith\u0026#34;, \u0026#34;age\u0026#34;: 25 } Horizontal Rule 예시 없음 1 --- Footnote 예시 없음 1 2 Here\u0026#39;s a sentence with a footnote. [^1] Heading ID 예시 없음 1 # My Great Heading {#custom-id} Definition List 1 2 term :definition term definition Task List 1 2 3 - [x] Write the press release - [ ] Update the website - [ ] Contact the media Write the press release Update the website Contact the media Reference https://www.markdownguide.org/cheat-sheet https://gist.github.com/rxaviers/7360908 ","permalink":"https://jaeyeopme.github.io/posts/markdown-%EB%AC%B8%EB%B2%95-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/","summary":"Heading 1 2 3 4 5 6 7 8 9 10 11 # H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 H1 H2 H3 H4 H5 H6 Bold 1 **bold text** bold text\nItalic 1 _italicized text_ italicized text\nStrikethrough 1 ~~The world is flat.~~ The world is flat.\nEmoji 1 2 3 :kissing_closed_eyes: :satisfied: :stuck_out_tongue_winking_eye: :kissing_closed_eyes: :satisfied: :stuck_out_tongue_winking_eye:\nBlockquote 1 2 3 4 5 \u0026gt; blockquote1 \u0026gt; \u0026gt; \u0026gt; blockquote2 \u0026gt; \u0026gt; \u0026gt; \u0026gt; \u0026gt; blockquote3 blockquote1","title":"Markdown 문법"}]