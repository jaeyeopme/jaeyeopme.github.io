<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>HTTP 요약 | Jaeyeop's Notes</title><meta name=keywords content="HTTP"><meta name=description content="HTTP 0.9 GET 메서드 지원 텍스트 정보 전송 지원 1.0 페이로드와 헤더 지원 다양한 헤더 지원 Content-Type 이미지나 동영상 등 다양한 정보 전송 지원 Content-Encoding (최적화 기법) 압축 정보를 공유하여 압축 전송 지원 POST 메서드 지원 1.1 다양한 HTTP 메서드 지원 PUT, DELETE 등 지속적 연결 지원 TCP 연결을 재사용하여 파이프라이닝 먼저 보낸 요청의 응답을 완전하게 받지 않아도 다음 요청을 병렬적으로 처리하여 전체 전달시간을 줄이는 방식 요청만 병렬적으로 수행하기 때문에 응답은 여전히 FIFO 방식 HOL(Head Of-Line blocking) 문제 서버가 하나의 요청에 응답을 지연하면 나머지 모든 응답 역시 지연 2."><meta name=author content="jaeyeopme"><link rel=canonical href=https://jaeyeopme.github.io/posts/http-%EC%9A%94%EC%95%BD/><link crossorigin=anonymous href=/assets/css/stylesheet.b81af9c3b21c6fc25a8deffa023e29895d23615338885069e17e2cee96ab8f74.css integrity="sha256-uBr5w7Icb8Jaje/6Aj4piV0jYVM4iFBp4X4s7parj3Q=" rel="preload stylesheet" as=style><link rel=icon href=https://jaeyeopme.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jaeyeopme.github.io/img/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jaeyeopme.github.io/img/favicon-32x32.png><link rel=apple-touch-icon href=https://jaeyeopme.github.io/img/apple-touch-icon.png><link rel=mask-icon href=https://jaeyeopme.github.io/img/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="HTTP 요약"><meta property="og:description" content="HTTP 0.9 GET 메서드 지원 텍스트 정보 전송 지원 1.0 페이로드와 헤더 지원 다양한 헤더 지원 Content-Type 이미지나 동영상 등 다양한 정보 전송 지원 Content-Encoding (최적화 기법) 압축 정보를 공유하여 압축 전송 지원 POST 메서드 지원 1.1 다양한 HTTP 메서드 지원 PUT, DELETE 등 지속적 연결 지원 TCP 연결을 재사용하여 파이프라이닝 먼저 보낸 요청의 응답을 완전하게 받지 않아도 다음 요청을 병렬적으로 처리하여 전체 전달시간을 줄이는 방식 요청만 병렬적으로 수행하기 때문에 응답은 여전히 FIFO 방식 HOL(Head Of-Line blocking) 문제 서버가 하나의 요청에 응답을 지연하면 나머지 모든 응답 역시 지연 2."><meta property="og:type" content="article"><meta property="og:url" content="https://jaeyeopme.github.io/posts/http-%EC%9A%94%EC%95%BD/"><meta property="og:image" content="https://jaeyeopme.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-15T18:00:00+00:00"><meta property="article:modified_time" content="2022-09-15T18:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jaeyeopme.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="HTTP 요약"><meta name=twitter:description content="HTTP 0.9 GET 메서드 지원 텍스트 정보 전송 지원 1.0 페이로드와 헤더 지원 다양한 헤더 지원 Content-Type 이미지나 동영상 등 다양한 정보 전송 지원 Content-Encoding (최적화 기법) 압축 정보를 공유하여 압축 전송 지원 POST 메서드 지원 1.1 다양한 HTTP 메서드 지원 PUT, DELETE 등 지속적 연결 지원 TCP 연결을 재사용하여 파이프라이닝 먼저 보낸 요청의 응답을 완전하게 받지 않아도 다음 요청을 병렬적으로 처리하여 전체 전달시간을 줄이는 방식 요청만 병렬적으로 수행하기 때문에 응답은 여전히 FIFO 방식 HOL(Head Of-Line blocking) 문제 서버가 하나의 요청에 응답을 지연하면 나머지 모든 응답 역시 지연 2."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://jaeyeopme.github.io/posts/"},{"@type":"ListItem","position":3,"name":"HTTP 요약","item":"https://jaeyeopme.github.io/posts/http-%EC%9A%94%EC%95%BD/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"HTTP 요약","name":"HTTP 요약","description":"HTTP 0.9 GET 메서드 지원 텍스트 정보 전송 지원 1.0 페이로드와 헤더 지원 다양한 헤더 지원 Content-Type 이미지나 동영상 등 다양한 정보 전송 지원 Content-Encoding (최적화 기법) 압축 정보를 공유하여 압축 전송 지원 POST 메서드 지원 1.1 다양한 HTTP 메서드 지원 PUT, DELETE 등 지속적 연결 지원 TCP 연결을 재사용하여 파이프라이닝 먼저 보낸 요청의 응답을 완전하게 받지 않아도 다음 요청을 병렬적으로 처리하여 전체 전달시간을 줄이는 방식 요청만 병렬적으로 수행하기 때문에 응답은 여전히 FIFO 방식 HOL(Head Of-Line blocking) 문제 서버가 하나의 요청에 응답을 지연하면 나머지 모든 응답 역시 지연 2.","keywords":["HTTP"],"articleBody":"HTTP 0.9 GET 메서드 지원 텍스트 정보 전송 지원 1.0 페이로드와 헤더 지원 다양한 헤더 지원 Content-Type 이미지나 동영상 등 다양한 정보 전송 지원 Content-Encoding (최적화 기법) 압축 정보를 공유하여 압축 전송 지원 POST 메서드 지원 1.1 다양한 HTTP 메서드 지원 PUT, DELETE 등 지속적 연결 지원 TCP 연결을 재사용하여 파이프라이닝 먼저 보낸 요청의 응답을 완전하게 받지 않아도 다음 요청을 병렬적으로 처리하여 전체 전달시간을 줄이는 방식 요청만 병렬적으로 수행하기 때문에 응답은 여전히 FIFO 방식 HOL(Head Of-Line blocking) 문제 서버가 하나의 요청에 응답을 지연하면 나머지 모든 응답 역시 지연 2.0 프로토콜 경량화 텍스트 방식을 버리고 바이너리를 사용하여 프로토콜 경량화 헤더와 페이로드가 이진형태의 프레임으로 추상화 이진 프레임 프레임: 제일 작은 정보 단위이며 헤더나 데이터 중 하나 메시지: HTTP/1.1 마찬가지로 요청 혹은 응답 단위이며 다수의 프레임으로 이루어짐 스트림: 클라이언트와 서버 사이 맺어진 연결을 통해 양방향으로 주고받는 하나 혹은 복수의 메시지 스트림 식별자 스트림에는 식별자가 있는데 요청과 응답은 같은 식별자를 가짐 프레임 헤더에 있는 식별자를 통해 프레임을 재조립하기 때문에 서버 측에서 요청 순서에 상관 없이 식별하여 응답 가능 멀티플렉싱 스트림 식별자를 통해 요청 순서가 보장되기 때문에 응답 프레임들은 요청 순서에 상관 없이 만들어진 순서대로 전달 요청과 응답 모두 병렬적으로 수행 HOL 문제 해결 헤더 압축 기존에는 Content-Encoding 헤더를 통해 페이로드만 압축 가능 가상 테이블 클라이언트와 서버 사이에 중복된 헤더 값들을 테이블에 저장하고 참고하는 방식으로 중복 전달 제거 각 테이블에는 인덱스 번호가 있기 때문에 동일한 값을 전송할 때는 중복 값을 보내는 대신 인덱스 번호로 대체하여 전송 정적 테이블과 동적 테이블로 나눠짐 정적 테이블 미리 정의된 자주 사용되는 헤더 필드 저장 동적 테이블 통신하며 주고받는 값들을 업데이트 HPACK 압축 알고리즘을 사용하여 허프만 알고리즘 방식으로 헤더를 압축 허프만 알고리즘 자주 등장하는 값과 그렇지 않은 값 마다 코드 값을 다르게 부여하는 알고리즘 스트림 우선 순위 설정 서버 푸시 클라이언트가 요청하지 않아도 미리 전송하여 RTT 최소화 가능 예를 들어 HTML을 호출한 후 후속으로 해당 페이지가 호출하는 CSS 파일이나 자바스크립트, 이미지 등 대상이 고정되어 있다면 서버 푸시 대상으로 미리 설정 가능 최근 APM 솔루션들은 서버 푸시 대상을 자동으로 설정해주는 기능을 포함 후속 파일 대상이 변경되어도 이를 자동으로 탐지하고 적용하는 기능이 포함 3.0 QUIC (Quick UDP Internet Connections) UDP 를 채택해 TCP 성능을 개선하려는 기술 속도 향상과 연결 수를 최소화하고 대역폭을 예상해 패킷 혼잡을 피하는것이 주요 목적 Zero RTT 이전에 한번이라도 접속했던 서버라면, 별도의 정보교환 없이 바로 데이터를 보냄 3 hand-shaking 캐시 HQ (HTTP over QUIC) TCP/IP 기반 애플리케이션 레이어 프로토콜인 HTTP 를 QUIC 위로 위치 시킴 HTTP 3을 도입했을 때 나오는 변화들은 HTTP 3 때문이 아니라 QUIC 때문임 HTTP 3는 통신을 하려는 장치일 뿐 TLS 1.3 QUIC 은 프로토콜 단에서 암호화된 통신을 강제함 TLS 핸드 셰이크와 QUIC 핸드 셰이크가 동시에 발생하기 때문에 라운드 트립을 한번 절약하는 효과 암호화 영역 확장 헤더 필드 영역까지 암호화되기 때문에 헤더의 정보를 사용하는 ISP 나 네트워크 중계회사들은 도입 시 주의해야함 보안성은 강화했지만 패킷별로 암호화하기 때문에 TSL-TCP 에서 패킷을 묶어서 암호화하는것 보다 더 큰 리소스 소모가 생김 여러 파일 동시 통신 TCP 는 하나의 커넥션을 하나의 파일로 취급하기 때문에 로스가 발생하면, 해당 파일 뿐만 아니라 TCP 커넥션을 공유하는 다른 파일들의 패킷도 중단되는 문제가 발생할 수 있음 QUIC 는 개별 파일을 구분하기 때문에 패킷 로스가 발생해도 해당 파일의 스트림만 정지되도록 가능 커넥션 유지 커넥션을 구분하기 위해서는 클라이언트와 서버 각각의 아이피와 포트 이렇게 네가지가 필요 모바일 환경에서 와이파이존에서 데이터를 사용할 경우 일시적 지연이 일어나는 이유는 클라이언트 아이피가 바뀌기 때문 TCP 통신에서는 핸드 셰이크부터 다시 해야함 서버와 클라이언트는 커넥션 ID 를 기억하여 핸드셰이크를 진행하지 않아도 됌 ","wordCount":"547","inLanguage":"en","datePublished":"2022-09-15T18:00:00Z","dateModified":"2022-09-15T18:00:00Z","author":{"@type":"Person","name":"jaeyeopme"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jaeyeopme.github.io/posts/http-%EC%9A%94%EC%95%BD/"},"publisher":{"@type":"Organization","name":"Jaeyeop's Notes","logo":{"@type":"ImageObject","url":"https://jaeyeopme.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jaeyeopme.github.io accesskey=h title="Jaeyeop's Notes (Alt + H)">Jaeyeop's Notes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jaeyeopme.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://jaeyeopme.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jaeyeopme.github.io/tags/ title=Tag><span>Tag</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jaeyeopme.github.io>Home</a>&nbsp;»&nbsp;<a href=https://jaeyeopme.github.io/posts/>Posts</a></div><h1 class=post-title>HTTP 요약</h1><div class=post-meta><span title='2022-09-15 18:00:00 +0000 UTC'>September 15, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;547 words&nbsp;·&nbsp;jaeyeopme</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#http>HTTP</a><ul><li><a href=#09>0.9</a></li><li><a href=#10>1.0</a></li><li><a href=#11>1.1</a></li><li><a href=#20>2.0</a></li><li><a href=#30>3.0</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=http>HTTP<a hidden class=anchor aria-hidden=true href=#http>#</a></h2><h3 id=09>0.9<a hidden class=anchor aria-hidden=true href=#09>#</a></h3><ul><li>GET 메서드 지원</li><li>텍스트 정보 전송 지원</li></ul><h3 id=10>1.0<a hidden class=anchor aria-hidden=true href=#10>#</a></h3><ul><li>페이로드와 헤더 지원</li><li>다양한 헤더 지원<ul><li>Content-Type<ul><li>이미지나 동영상 등 다양한 정보 전송 지원</li></ul></li><li>Content-Encoding (최적화 기법)<ul><li>압축 정보를 공유하여 압축 전송 지원</li></ul></li></ul></li><li>POST 메서드 지원</li></ul><h3 id=11>1.1<a hidden class=anchor aria-hidden=true href=#11>#</a></h3><ul><li>다양한 HTTP 메서드 지원<ul><li>PUT, DELETE 등</li></ul></li><li>지속적 연결 지원<ul><li>TCP 연결을 재사용하여</li></ul></li><li>파이프라이닝<ul><li>먼저 보낸 요청의 응답을 완전하게 받지 않아도 다음 요청을 병렬적으로 처리하여 전체 전달시간을 줄이는 방식</li><li>요청만 병렬적으로 수행하기 때문에 응답은 여전히 FIFO 방식</li><li>HOL(Head Of-Line blocking) 문제<ul><li>서버가 하나의 요청에 응답을 지연하면 나머지 모든 응답 역시 지연</li></ul></li></ul></li></ul><h3 id=20>2.0<a hidden class=anchor aria-hidden=true href=#20>#</a></h3><ul><li>프로토콜 경량화<ul><li>텍스트 방식을 버리고 바이너리를 사용하여 프로토콜 경량화</li><li>헤더와 페이로드가 이진형태의 프레임으로 추상화</li></ul></li><li>이진 프레임<ul><li>프레임: 제일 작은 정보 단위이며 헤더나 데이터 중 하나</li><li>메시지: HTTP/1.1 마찬가지로 요청 혹은 응답 단위이며 다수의 프레임으로 이루어짐</li><li>스트림: 클라이언트와 서버 사이 맺어진 연결을 통해 양방향으로 주고받는 하나 혹은 복수의 메시지</li></ul></li><li>스트림 식별자<ul><li>스트림에는 식별자가 있는데 요청과 응답은 같은 식별자를 가짐</li><li>프레임 헤더에 있는 식별자를 통해 프레임을 재조립하기 때문에 서버 측에서 요청 순서에 상관 없이 식별하여 응답 가능</li></ul></li><li>멀티플렉싱<ul><li>스트림 식별자를 통해 요청 순서가 보장되기 때문에 응답 프레임들은 요청 순서에 상관 없이 만들어진 순서대로 전달</li><li>요청과 응답 모두 병렬적으로 수행 HOL 문제 해결</li></ul></li><li>헤더 압축<ul><li>기존에는 Content-Encoding 헤더를 통해 페이로드만 압축 가능</li><li>가상 테이블<ul><li>클라이언트와 서버 사이에 중복된 헤더 값들을 테이블에 저장하고 참고하는 방식으로 중복 전달 제거</li><li>각 테이블에는 인덱스 번호가 있기 때문에 동일한 값을 전송할 때는 중복 값을 보내는 대신 인덱스 번호로 대체하여 전송</li><li>정적 테이블과 동적 테이블로 나눠짐<ul><li>정적 테이블<ul><li>미리 정의된 자주 사용되는 헤더 필드 저장</li></ul></li><li>동적 테이블<ul><li>통신하며 주고받는 값들을 업데이트</li></ul></li></ul></li></ul></li><li>HPACK 압축 알고리즘을 사용하여 허프만 알고리즘 방식으로 헤더를 압축<ul><li>허프만 알고리즘<ul><li>자주 등장하는 값과 그렇지 않은 값 마다 코드 값을 다르게 부여하는 알고리즘</li></ul></li></ul></li></ul></li><li>스트림 우선 순위 설정</li><li>서버 푸시<ul><li>클라이언트가 요청하지 않아도 미리 전송하여 RTT 최소화 가능</li><li>예를 들어 HTML을 호출한 후 후속으로 해당 페이지가 호출하는 CSS 파일이나 자바스크립트, 이미지 등 대상이 고정되어 있다면 서버 푸시 대상으로 미리 설정 가능</li><li>최근 APM 솔루션들은 서버 푸시 대상을 자동으로 설정해주는 기능을 포함<ul><li>후속 파일 대상이 변경되어도 이를 자동으로 탐지하고 적용하는 기능이 포함</li></ul></li></ul></li></ul><h3 id=30>3.0<a hidden class=anchor aria-hidden=true href=#30>#</a></h3><ul><li>QUIC (Quick UDP Internet Connections)<ul><li>UDP 를 채택해 TCP 성능을 개선하려는 기술</li><li>속도 향상과 연결 수를 최소화하고 대역폭을 예상해 패킷 혼잡을 피하는것이 주요 목적</li><li>Zero RTT<ul><li>이전에 한번이라도 접속했던 서버라면, 별도의 정보교환 없이 바로 데이터를 보냄<ul><li>3 hand-shaking 캐시</li></ul></li></ul></li></ul></li><li>HQ (HTTP over QUIC)<ul><li>TCP/IP 기반 애플리케이션 레이어 프로토콜인 HTTP 를 QUIC 위로 위치 시킴</li><li>HTTP 3을 도입했을 때 나오는 변화들은 HTTP 3 때문이 아니라 QUIC 때문임 HTTP 3는 통신을 하려는 장치일 뿐
<img loading=lazy src=images/1.png#center alt></li></ul></li><li>TLS 1.3<ul><li>QUIC 은 프로토콜 단에서 암호화된 통신을 강제함<ul><li>TLS 핸드 셰이크와 QUIC 핸드 셰이크가 동시에 발생하기 때문에 라운드 트립을 한번 절약하는 효과
<img loading=lazy src=images/2.png#center alt></li></ul></li><li>암호화 영역 확장<ul><li>헤더 필드 영역까지 암호화되기 때문에 헤더의 정보를 사용하는 ISP 나 네트워크 중계회사들은 도입 시 주의해야함</li><li>보안성은 강화했지만 패킷별로 암호화하기 때문에 TSL-TCP 에서 패킷을 묶어서 암호화하는것 보다 더 큰 리소스 소모가 생김
<img loading=lazy src=images/3.png#center alt></li></ul></li></ul></li><li>여러 파일 동시 통신<ul><li>TCP 는 하나의 커넥션을 하나의 파일로 취급하기 때문에 로스가 발생하면, 해당 파일 뿐만 아니라 TCP 커넥션을 공유하는 다른 파일들의 패킷도 중단되는 문제가 발생할 수 있음</li><li>QUIC 는 개별 파일을 구분하기 때문에 패킷 로스가 발생해도 해당 파일의 스트림만 정지되도록 가능
<img loading=lazy src=images/4.png#center alt></li></ul></li><li>커넥션 유지<ul><li>커넥션을 구분하기 위해서는 클라이언트와 서버 각각의 아이피와 포트 이렇게 네가지가 필요</li><li>모바일 환경에서 와이파이존에서 데이터를 사용할 경우 일시적 지연이 일어나는 이유는 클라이언트 아이피가 바뀌기 때문 TCP 통신에서는 핸드 셰이크부터 다시 해야함
<img loading=lazy src=images/5.png#center alt></li><li>서버와 클라이언트는 커넥션 ID 를 기억하여 핸드셰이크를 진행하지 않아도 됌
<img loading=lazy src=images/6.png#center alt></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jaeyeopme.github.io/tags/http/>HTTP</a></li></ul><nav class=paginav><a class=prev href=https://jaeyeopme.github.io/posts/%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-1%EC%9E%A5/><span class=title>« Prev</span><br><span>단위 테스트 1장</span></a>
<a class=next href=https://jaeyeopme.github.io/posts/solid/><span class=title>Next »</span><br><span>SOLID</span></a></nav></footer><script>(function(){let t=localStorage.getItem("pref-theme");t?t=t==="dark"?"github-dark":"github-light":"auto"!=="auto"?t="auto"==="dark"?"github-dark":"github-light":t=window.matchMedia("(prefers-color-scheme: dark)").matches?"github-dark":"github-light";const e=document.createElement("script");e.src="https://utteranc.es/client.js",e.crossorigin="anonymous",e.async=!0,e.setAttribute("repo","jaeyeopme/jaeyeopme.github.io"),e.setAttribute("issue-term","title"),e.setAttribute("label","comments 🦊"),e.setAttribute("theme",t),document.body.appendChild(e)})()</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{let e=localStorage.getItem("pref-theme");e?e=e==="dark"?"github-light":"github-dark":"auto"!=="auto"?e="auto"==="dark"?"github-light":"github-dark":e=window.matchMedia("(prefers-color-scheme: dark)").matches?"github-light":"github-dark";const t={type:"set-theme",theme:e};document.querySelector(".utterances-frame").contentWindow.postMessage(t,"https://utteranc.es")})</script></article></main><footer class=footer><span>&copy; 2023 <a href=https://jaeyeopme.github.io>Jaeyeop's Notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>